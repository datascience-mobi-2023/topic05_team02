---
title: "Data_Analysis_2023_AW"
author: "Arne Weigelt"
date: "2023-05-02"
output: html_document
---


load data
```{r}
#load("C:/Users/ArneW/OneDrive - bwedu/Bioinformatics/DATA_ANALYSIS_2023/prism_datasets.rda")
#load("C:/Users/ArneW/OneDrive - bwedu/Bioinformatics/DATA_ANALYSIS_2023/cellline_datasets.rda")


install.packages("tidyverse", "data.table", "magrittr", "reshape2")
install.packages("BiocManager")
BiocManager::install("sva")
install.packages("reshape2")

library(tidyverse)
library(data.table)
library(magrittr)
library(reshape2)
library(sva)
library(dplyr)
```

first look
```{r}
head(prism)
```
Histogramm der ersten Spalte
```{r}
plot(prism[,1])
hist(prism[,1], breaks=100)
```

NA Werte looki looki
```{r}
colnames(prism)[1]
sum(is.na(prism$"BRD-A00077618-236-07-6::0.00061034::HTS002"))
```

 Berechne/plot den Mittelwert/SD jeder Spalte des Dataframes, wobei NA-Werte ignoriert werden
```{r}
prism.col.mean= apply(prism, 2, function(x){mean(x, na.rm= T)})
plot(prism.col.mean)

prism.col.sd= apply(prism, 2, function(x){sd(x, na.rm= T)})
plot(prism.col.sd)

prism.col.min= sapply(prism, min, na.rm=T)
plot(prism.col.min)

```
Funktion, welche  columns nach parameter drug extrahiert in noch leeres df
```{r}
extract_columns <- function(prism, drug) {
  
  col_indices <- grep(drug, colnames(prism))
  
  # Erstelle ein neues Dataframe mit ausgewählten Spalten
  new_prism <- prism[, col_indices]
  
  return(new_prism)
}

```

extrahiert drug name // hätte man auch mit prism.treat machen können
`````{r}
prism.col.names= unique(sapply(strsplit(colnames(prism),"::"),`[`, 1))
```

fasst alle Spalten einer drug und Zeile zsm., erstellt mean, neues df
```{r}
prism.drug.means= data.frame(matrix(nrow= nrow(prism), ncol=0))
rownames(prism.drug.means)= rownames(prism)
for(drug in prism.col.names){
  df= extract_columns(prism, drug)
 prism.drug.means[drug]= rowMeans(df, na.rm=T)
}

```

heatmap des  mean
```{r}
pheatmap(na.omit(prism.drug.means), show_colnames=F, show_rownames=F)
```
zeigt alle moa o.ä. der drugs mit einem drug mean unter threshold x an // moa und threshold änderbar
```{r}
idx= colnames(prism.drug.means[which(apply(prism.drug.means, 2, min, na.rm=T)< -1.8)])

unique(prism.treat[prism.treat$broad_id %in% idx,]$moa)
```



```{r}


prism.col.mean= colMeans(prism.drug.means, na.rm=T)
plot(prism.col.mean)

prism.col.var= apply(prism.drug.means, 2, function(x){var(x, na.rm= T)})
plot(prism.col.var)


plot(density(prism.col.mean, na.rm=T))
plot(density(prism.col.var, na.rm=T))
#Define q10
q10= quantile(prism.drug.means, 0.1, na.rm=T )
q10
#!!NOT WORKING YET!!:
prism.drug.means.q10= prism.drug.means<q10
# Zähle die Anzahl der TRUE-Werte in jeder Spalte (ignoriert NA-Werte)
col_counts = colSums(isTRUE(prism.drug.means.q10))

# Finde Spalten, die nur FALSE enthalten
cols_to_remove = col_counts == 0

# Entferne die entsprechenden Spalten
prism.drug.means.q10 = prism.drug.means.q10[, !cols_to_remove, drop = FALSE]



```










DATA CLEANUP
```{r}
rownames(prism.cl)= prism.cl$DepMap_ID
prism.cl=prism.cl[-c(1)]
prism.cl=prism.cl[,c(1,12,11,15,16,5,19,6,18)]

```



















```{r}
#rownumbers of prism.cl with Kidney Cancer
which(prism.cl$disease== "Kidney Cancer")

cl.kidney= prism.cl[c(which(prism.cl$disease== "Kidney Cancer")),]
```


```{r}
#kidney cancer exclusive df from prism.drug.means
prism.drug.means.kidney= prism.drug.means[rownames(cl.kidney),]

prism.drug.means.kidney.col.mean= apply(prism.drug.means.kidney, 2, function(x){mean(x, na.rm= T)})
plot(density(prism.drug.means.kidney.col.mean))

prism.drug.means.kidney.col.sd= apply(prism.drug.means.kidney, 2, function(x){sd(x, na.rm= T)})
plot(density(prism.drug.means.kidney.col.sd))
```


```{r}
idx.kidney= colnames(prism.drug.means.kidney[which(apply(prism.drug.means.kidney, 2, min, na.rm=T)< -1.8)])

unique(prism.treat[prism.treat$broad_id %in% idx.kidney,]$moa)
```






























