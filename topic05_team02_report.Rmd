---
title: "topic05_team02_report"
author: "Jessica Albrecht, Franca Klaeren & Arne Weigel"
date: "2023-07-05"
output:
  pdf_document:
    toc: yes
    toc_depth: 4
editor_options: 
  markdown: 
    wrap: sentence
bibliography: topic05_team02_references.bib
---

# Report

## Introduction

The repurposing of non-oncology drugs, is one way to find potential treatments for cancer in the future.
This offers several advantages over the development of new drugs.
For example, initial study phases can be shortened or skipped altogether because studies have already been completed.
So time and money can be saved through that @Pushpakom_2018 @Corsello_2020.

Many drugs interact with multiple targets and biological pathways beyond their originally intended purpose.

Beschreibung der Fragestellung, Vorstellung der publizierten Vorarbeiten,\...

## Material and Methods

```{r load_datasets, include=FALSE}
load("C:/Users/Jessica Albrecht/Desktop/Uni/BioInfo Project/cellline_datasets.rda")
load("C:/Users/Jessica Albrecht/Desktop/Uni/BioInfo Project//prism_datasets.rda")
```

The data we used for the project was published by Corsello et al. @Corsello_2020 and Dempster et al. @Dempster_2019.

bitte hier die Referenzen der Publikationen/Webseiten, aus denen die Daten stammen, und die Beschreibung der Methoden, die benutzt wurden.

#### What data do we have and what does it tell us?

prism.exp: This dataset shows the Transcripts per million of the genes (columns) for the cell lines (rows).
prism.treat: The dataset shows for each treatment (rows) information about the drugs and dosis.
prism: This dataset shows the treatment effects (columns) on the cell growth for each cell line (rows).
prism.achilles: This dataset shows gene knockout-scores, representing the importance of one gene for cell survival, of every gene (columns) for the cell lines (rows).
prism.cnv:

### data cleanup

Before we started to work with our data sets, we first had to do some data cleanup.
For that we generated some sub-data sets for the 17 kidney cancer cell lines and for some areas of application we needed to set NA-values to zero.

```{r cleanup_cols_prism.cl, include=FALSE}
#reorder columns of prism.cl
colnames(prism.cl)
prism.cl<-prism.cl[,c(1,2,12,6,20,7,19)]

##make cell lines as row names
rownames(prism.cl)=prism.cl$DepMap_ID
```

```{r kidney_cancer_subsets, include=FALSE}
#rownumbers of prism.cl with Kidney Cancer
which(prism.cl$disease== "Kidney Cancer")

prism.cl.kidney= prism.cl[c(which(prism.cl$disease== "Kidney Cancer")),]

#Gives back all cell lines which are kidney-cancer-cell lines
kidney_celllines<-print(prism.cl.kidney[,1])

#Gives back all cell line ACh-numbers which are cancer-cell lines
kidney_celllines_ACH <-rownames(prism.cl.kidney)

#stores only kidney cancer cell lines from other datasets in a new one
prism.exp.kidney <- prism.exp[kidney_celllines_ACH, ]

#for prism dataset
prism.kidney <- prism[rownames(prism) %in% kidney_celllines_ACH,]

#for prism.achilles
prism.achilles.kidney<- prism.achilles[rownames(prism.achilles) %in% kidney_celllines_ACH,]
```

```{r NA_0, include=FALSE}
#set NA to 0
prism_NA_0 <- prism
prism_NA_0[is.na(prism_NA_0)] <- 0 

prism.kidney_NA_0<-prism.kidney
prism.kidney_NA_0[is.na(prism.kidney_NA_0)] <- 0

prism.achilles.kidney_NA_0<-prism.achilles.kidney
prism.achilles.kidney_NA_0[is.na(prism.achilles.kidney_NA_0)] <- 0
```

```{r cancer_type_vector, include=FALSE}
unique(prism.cl$disease)
cancertypes<- c(unique(prism.cl$disease))
```

```{r prism_list, include=FALSE}
# Create a list to store data frames for each cancer type
prism_list <- list()

# Loop over the cancertypes vector
for (cancer_type in cancertypes) {
  # Subset the prism.cl data frame for the current cancer type
  cancer_df <- prism.cl[which(prism.cl$disease == cancer_type), ]
  
  # Subset the prism.exp data frame based on the row names from the cancer_df
  prism_subset <- prism_NA_0[rownames(cancer_df), ]
  
  # Store the subsetted prism.exp in the list with the cancer type as the list name
  prism_list[[cancer_type]] <- prism_subset
}
# Access the data frames for specific cancer types from the list
prism_list[["Sarcoma"]]
# Access other cancer types similarly
```

```{r top_var_list, include=FALSE}
prism.var_list<-list()
# Loop over the cancertypes vector
for (cancer_type in names(prism_list)) {
  
  prism.var<- apply(prism_NA_0,MARGIN=2,FUN=var)
  prism.topvar=prism_NA_0[rownames(cancer_df),which(prism.var>=quantile(prism.var,probs=0.75,na.rm=TRUE))]
  
  prism.topvar.NA_0<-prism.topvar
  prism.topvar.NA_0[is.na(prism.topvar.NA_0)]<-0
  # Store the subsetted prism.exp in the list with the cancer type as the list name
  prism.var_list[[cancer_type]] <- prism.topvar.NA_0
}
#retrieve 75% var-quantile for each cancer type:
prism.var_list[[cancer_type]]
```

```{r prism_exp_list, include=FALSE}
# Create a list to store data frames for each cancer type
prism_exp_list <- list()

# Loop over the cancertypes vector
for (cancer_type in cancertypes) {
  # Subset the prism.cl data frame for the current cancer type
  cancer_df <- prism.cl[which(prism.cl$disease == cancer_type), ]
  
  # Subset the prism.exp data frame based on the row names from the cancer_df
  prism_exp_subset <- prism.exp[rownames(cancer_df), ]
  
  # Store the subsetted prism.exp in the list with the cancer type as the list name
  prism_exp_list[[cancer_type]] <- prism_exp_subset
}

# Access the data frames for specific cancer types from the list
prism_exp_list[["lung cancer"]]
# Access other cancer types similarly
```

### STatistical tests

##Kolmogorov-Smirnov-test The Kolgomogorov-SMirnov-test can be a one-sample or a two-sample test.
In this report only the one-sample test was used.
The null-hypothesis of this test is: "The random variable X follows the probability distribution F0." The empiric distribution Fn is then compared to the given distribution F0.
The comparitive characteristic is the maximal distance between the two distributions.
The larger the distance the less likely it is for F0 to follow Fn.

## Results

Darstellung der Ergebnisse und Abbildungen

### descriptive statistics

For a quick overview of the content we printed the headlines of the data sets for example for prism.cl.

```{r head_prism.cl, echo=FALSE}
head(prism.cl)
```

```{r distribution_histograms, echo=FALSE}
par(mfrow=c(2,2))
hist(unlist(prism), breaks = 60, main = "Histogram of prism", xlab = "treatment effect values")

hist(unlist(prism.exp), breaks = 60, main = "Histogram of prism.exp", xlab = "transcripts per million")

hist(unlist(prism.achilles), breaks = 60,main = "Histogram of prism.achilles", xlab = "gene knockout-scores")

hist(unlist(prism.cnv), main= "Histogram of prism.cnv", xlab="copy number variation", breaks=60)
```

The data distribution of prism.exp, prism.achilles, prism.cnv and prism is not normaly distributed [Anderson-Darling normality test (p-value \< 2.2e-16)].
The Anderson-Darling test allows conclusions about wheater a given data sample follows a particular distribution or not.
Here we checked against normal distribution.
In contrast to the Kolmogorov-Smirnov test, more attention is paid to the tails and it is possible to consider larger data sets.

```{r check_normal_distribution, include=FALSE}
#values as vectors
prism_vector <- unlist(prism)
prism.achilles_vector<-unlist(prism.achilles)
prism.exp_vector<- unlist(prism.exp)
prism.cnv_vector<-unlist(prism.cnv)

# Perform the Anderson-Darling normality test
library(nortest)
hyp_test_prism_distribution<- ad.test(prism_vector)
hyp_test_prism_distribution

hyp_test_prism.achilles_distribution<-ad.test(prism.achilles_vector)
hyp_test_prism.achilles_distribution

hyp_test_prism.exp_vector<-ad.test(prism.exp_vector)
hyp_test_prism.exp_vector

hyp_test_prism.cnv_vector<-ad.test(prism.cnv_vector)
hyp_test_prism.cnv_vector
```

```{r boxplot_prism_cnv_ach, echo=FALSE}
boxplot(
  prism_vector,prism.cnv_vector, prism.achilles_vector,
  outline = FALSE,
  names=c("prism", "prism.cnv", "prism.achilles"))
```

The boxplot of the data shows small inter quartile ranges for prism.cnv and prism.achilles and a bigger range for the prism data set.
This means we have more spreaded values for prism than for the other two data sets.

#### Correlation

##### between knock-out scores and expression

In order to search for high effective drugs, targeting essential genes of kidney cancer different steps are needed to be done.

First, calculating the correlation between the achilles knock-out scores and the expression values for each gene, results in correlation values which indicate how essential the genes are.
To calculate the correlation correctly, it is necessary to have the same size and order of data in both data sets.

```{r essential_genes, include=FALSE}
#old~new
#cnv~exp
#exp~ach
#identify missing rows in exp that are present in achilles
diff_rows <- setdiff(rownames(prism.exp.kidney), rownames(prism.achilles.kidney))
diff_rows <- unique(c(diff_rows, setdiff(rownames(prism.achilles.kidney), rownames(prism.exp.kidney))))
#print(diff_rows)

#prism.exp.kidney_corr_cleaned<-prism.exp.kidney
#"ACH-000046" "ACH-000171" "ACH-000313" "ACH-000428" "ACH-000429" "ACH-000457"
#which(rownames(prism.exp.kidney)=="ACH-000457")
#2,4,7,9,10,12
prism.exp.kidney_corr_cleaned<- prism.exp.kidney[-c(2,4,7,9,10,12),]

#identify missing columns that are present in prism.exp.kidney_corr_cleaned but not in achilles
diff_cols <- setdiff(colnames(prism.exp.kidney), colnames(prism.achilles.kidney))
diff_cols <- unique(c(diff_cols, setdiff(colnames(prism.achilles.kidney), colnames(prism.exp.kidney))))
#print(diff_cols)


diff_cols2 <- setdiff(colnames(prism.achilles.kidney), colnames(prism.exp.kidney))
diff_cols2<- unique(c(diff_cols, setdiff(colnames(prism.exp.kidney), colnames(prism.achilles.kidney))))
prism.exp.kidney_corr_cleaned<-prism.exp.kidney_corr_cleaned[-which(colnames(prism.exp.kidney) %in% diff_cols)]
prism.achilles.kidney_corr_cleaned<-prism.achilles.kidney[-which(colnames(prism.achilles.kidney) %in% diff_cols2)]

#reorder rows in an ascending way
#1.step:rownames(prism.exp.kidney_corr_cleaned)
prism.exp.kidney_corr_cleaned<- prism.exp.kidney_corr_cleaned[order(rownames(prism.exp.kidney_corr_cleaned)),]
prism.achilles.kidney_corr_cleaned<- prism.achilles.kidney_corr_cleaned[order(rownames(prism.achilles.kidney_corr_cleaned)),]

#reorder columns by names
prism.exp.kidney_corr_cleaned= prism.exp.kidney_corr_cleaned[,colnames(prism.achilles.kidney_corr_cleaned)]

correlation_ach_exp_kidney<-matrix()
for (g in colnames(prism.achilles.kidney_corr_cleaned)) {  
  valse_g_ach_exp_kidney = prism.achilles.kidney_corr_cleaned[,colnames(prism.achilles.kidney_corr_cleaned) == g]  
  valsc_g_ach_exp_kidney = prism.exp.kidney_corr_cleaned[,colnames(prism.exp.kidney_corr_cleaned) == g]  
  correlation_ach_exp_kidney[[g]]=cor(valse_g_ach_exp_kidney, valsc_g_ach_exp_kidney, method= c("spearman"))  
}  
final_correlation_ach_exp_kidney = t(data.frame(correlation_ach_exp_kidney))

colnames_pos_corr <- colnames(final_correlation_ach_exp_kidney)[which(final_correlation_ach_exp_kidney >= quantile(final_correlation_ach_exp_kidney, 0.98, na.rm = TRUE))]

colnames_neg_corr <- colnames(final_correlation_ach_exp_kidney)[which(final_correlation_ach_exp_kidney <= quantile(final_correlation_ach_exp_kidney, 0.02, na.rm = TRUE))]

high_corr_genenames<-c(colnames_neg_corr, colnames_pos_corr)
```

```{r correlation_histogram, echo=FALSE}
hist(correlation_ach_exp_kidney, breaks = 40)
qu<-quantile(correlation_ach_exp_kidney, 0.02, na.rm = TRUE)
abline(v=c(-qu,qu))
```

###### **Which drugs do have a high negative effect on the cell lines?**

In order to slow down or even prevent the growth of tumor cells, we are looking for drugs of which a negative value was obtained in the prism screening.
Since the effect should be as strongly negative as possible, it was decided, after considering the distribution of prism values, to classify drugs below a threshold of the 2% quartile of prism values as highly effective drugs.

```{r neg_effect_drugs, include=FALSE}
#Set threshold depending on the distribution of prism 
prism.kidney_threshold<- quantile(prism.kidney, 0.02, na.rm=TRUE)

                                                
# Create an empty vector to store the column names
high_effect_drugs_kidney <- c()

# Iterate over each column of the dataset
for (col in colnames(prism.kidney_NA_0)) {
  # Check if any value in the column is lower than the threshold
  if (any(prism.kidney_NA_0[, col] <= prism.kidney_threshold)) {
    # If true, append the column name to the vector
    high_effect_drugs_kidney <- c(high_effect_drugs_kidney, col)
  }
}
#subset of prism.treat for drugs with inhibiting impact on kidney cancer cells
#Show/store the filtered rows
prism.treat.kidney.high_effect_drugs<-print(prism.treat[rownames(prism.treat) %in% high_effect_drugs_kidney,])


prism.treat.kidney.high_effect_drugs$target <- as.character(prism.treat.kidney.high_effect_drugs$target)


# Extract all targets as a single character vector
targetgenes_high_effect_drugs_kidney <- 
  unlist(strsplit(prism.treat.kidney.high_effect_drugs$target, ", "))

# Remove any leading/trailing white spaces and NA values
targetgenes_high_effect_drugs_kidneys <- trimws(targetgenes_high_effect_drugs_kidney)
targetgenes_high_effect_drugs_kidney <- targetgenes_high_effect_drugs_kidney[!is.na(targetgenes_high_effect_drugs_kidney)]

# Print the resulting vector of targets
#print(targetgenes_high_effect_drugs_kidney)
```

After identifying both essential genes and the target genes of the highly effective drugs, we then searched for overlaps between these two groups.

```{r venn_genes, include=FALSE}
# Create a list of the gene names in each vector
set1 <- unique(high_corr_genenames)
set2 <- unique(targetgenes_high_effect_drugs_kidney)

list_venn1<-list(set1, set2)

# Create the Venn diagram
library(VennDiagram)
venn1<-venn.diagram(
  list_venn1 ,
  category.names = c("essential genes(high corr. btw. prism.ach & prism.exp)", "target genes of high effective drugs "),
  fill = c("lightblue", "steelblue4"),
  main ="venn diagram",
  main.fontface= "bold",
  sub = "essential genes vs.target genes of high effective drugs ",
  col= "white",
  cat.pos= 9,
  filename = NULL
)
grid.newpage()

```

```{r venn_diagramm, echo=FALSE}
grid.draw(venn1)
```

This resulted in 21 target genes being identified.

```{r intersect_genes, echo=FALSE}
#find the genes in the intersection
intr_targets <- intersect(set1, set2)
intr_targets
```

###### Details of those target genes

To learn more details about the target genes, both the number and type of occurring mutations or variants of these genes, as well as their correlation values were examined in more detail.

```{r subsets_targets, include=FALSE}
prism.snv_intr_targets<-prism.snv[prism.snv$Hugo_Symbol %in% intr_targets,]

corr_ach_exp_kidney_intr_targets<-final_correlation_ach_exp_kidney[,colnames(final_correlation_ach_exp_kidney) %in% intr_targets]
corr_ach_exp_kidney_intr_targets<-as.data.frame(corr_ach_exp_kidney_intr_targets)

df_corr_ach_exp_kidney_intr_targets <- data.frame(Genes = rownames(corr_ach_exp_kidney_intr_targets), Values = as.numeric(corr_ach_exp_kidney_intr_targets[,1]))
```

```{r plot_details_target_genes, echo=FALSE}

#count_mutations<-as.vector(prism.snv_intr_targets$Hugo_Symbol)
#count_mutations<-table(vector_count_mutations)

#df.count_mutations<-as.data.frame(count_mutations)

library(ggplot2)
library(RColorBrewer)


####mutation plot
color_palette <- brewer.pal(9, "GnBu")

mutation_plot<-ggplot(prism.snv_intr_targets, aes(x = Hugo_Symbol, fill = Variant_Classification)) +
  geom_bar() +
  scale_fill_manual(values = color_palette) +
  labs(x = "gene", y = "Count", title = "Variant classifications of possible target genes") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 55, hjust = 1))

####correlation plot
color_palette_1 <- colorRampPalette(colors = c("steelblue", "steelblue4"))(21)

correlation_plot<-ggplot(df_corr_ach_exp_kidney_intr_targets, aes(x = Genes, y = Values)) +
  geom_bar(stat = "identity", fill=color_palette_1) +
  xlab("target genes") +
  ylab("correlation values") +
  ggtitle("correlation values of target genes")+
  theme(axis.text.x = element_text(angle = 55, hjust = 1))

```

##### between copy number variation and expression

As genes lead to the production of effector molecules (mRNA, proteins, etc.) it is interesting to see if a gene product associated with a disease (as disease inhibiting or disease promoting factor) can be amplified by a higher or reduced by a lower (0 or 1) number of gene copies in the genome.

In order to perform the correlation analysis the questioned data frames need to have the same dimension and the same order of genes and celllines.

```{r order_cnv&exp_corr, include=FALSE}
### Reordering of cnv and exp for correlation analysis
#identify missing rows in exp that are present in cnv
diff_rows <- setdiff(rownames(prism.cnv), rownames(prism.exp))
diff_rows <- unique(c(diff_rows, setdiff(rownames(prism.exp), rownames(prism.cnv))))

#prism.cnv_corr_cleaned<-prism.cnv[-c("ACH-000309","ACH-000047","ACH-000979","ACH-001024")]
#which(rownames(prism.cnv)=="ACH-001024")
prism.cnv_corr_cleaned<- prism.cnv[-c(85,268,294,307),]

#identify missing columns that are present in cnv but not in exp
diff_cols <- setdiff(colnames(prism.cnv), colnames(prism.exp))
diff_cols <- unique(c(diff_cols, setdiff(colnames(prism.exp), colnames(prism.cnv))))

diff_cols2 <- setdiff(colnames(prism.exp), colnames(prism.cnv))
diff_cols2<- unique(c(diff_cols, setdiff(colnames(prism.cnv), colnames(prism.exp))))
prism.cnv_corr_cleaned<-prism.cnv_corr_cleaned[-which(colnames(prism.cnv) %in% diff_cols)]
prism.exp_corr_cleaned<-prism.exp[-which(colnames(prism.exp) %in% diff_cols2)]

#reorder rows in an ascending way
#1.step:rownames(prism.cnv_corr_cleaned)
prism.cnv_corr_cleaned<- prism.cnv_corr_cleaned[order(rownames(prism.cnv_corr_cleaned)),]
prism.exp_corr_cleaned<- prism.exp_corr_cleaned[order(rownames(prism.exp_corr_cleaned)),]

#reorder columns by names
prism.cnv_corr_cleaned= prism.cnv_corr_cleaned[,colnames(prism.exp_corr_cleaned)]
```

The correlation was computed for each gene once using only the kidney cell line samples and once for the whole data set.
The whole-cell-line correlations show a lower dispersion (values rangig from -0.24 to +0.78) than the correlations computed with only kidney cell lines (range: -0.78 to +0.96) which can be explained by the amount of data.
While 16% of the overall correlation values lie below 0, kidney cell lines had showed lower correlation value (34.7% \<0) Overall, for some genes copy number variation seems to be highly correlated for some genes (high copy number variation-\> high gene expression), while for others there's even a negative correlation observable (high cnv-\> low exp).
As the histogram of the correlation values of kidney cell lines seems normally distributed, normality tests were performed.

```{r corr_exp_cnv, include=FALSE}
#correlation values
cor_g<-matrix()
for (g in colnames(prism.exp_corr_cleaned)) {  
  valse_g = prism.exp_corr_cleaned[,colnames(prism.exp_corr_cleaned) == g]  
  valsc_g = prism.cnv_corr_cleaned[,colnames(prism.cnv_corr_cleaned) == g]  
  cor_g[[g]]=cor(valse_g, valsc_g, method= c("spearman"))  
}  
final_cor = t(data.frame(cor_g))
#distribution of correlation values
h_final_cor= hist(final_cor)
#percentage with a correlation value below 0
sum(h_final_cor$counts[(which(h_final_cor$breaks <= 0))])/sum(h_final_cor$counts)

#correlation values for kidney cell lines
cor_kidney<-matrix()
for (g in colnames(prism.exp_corr_cleaned)) {  
  valse_g_kidney = prism.exp_corr_cleaned[rownames(prism_exp_list[["Kidney Cancer"]]),colnames(prism.exp_corr_cleaned) == g]  
  valsc_g_kidney = prism.cnv_corr_cleaned[rownames(prism_exp_list[["Kidney Cancer"]]),colnames(prism.cnv_corr_cleaned) == g]  
  cor_kidney[[g]]=cor(valse_g_kidney, valsc_g_kidney, method= c("spearman"))  
}  
kidney_cor = t(data.frame(cor_kidney))
#distribution of correlation values for kidney cell lines
hist(kidney_cor)
#percentage with a correlation value below 0
h_kidney_cor=hist(kidney_cor)
sum(h_kidney_cor$counts[(which(h_kidney_cor$breaks <= 0))])/sum(h_kidney_cor$counts)
```

```{r hist_corr_exp_cnv, echo=FALSE}
par(mfrow = c(1,2))
#distribution of correlation values
hist(final_cor)
hist(kidney_cor)
```

As the sample size exceeds 5000 it was not possible to perform a Shapiro-Wilks test, so for a first analysis a qqplot was plotted (kidney correlation values against a random normal distibution with n= sample size of correlation values and mean= mean of correlation values).
The line showing normal distribution did not align with the plotted values.
To confirm this result, a Kolmogorov-Smirnov test was performed.
In this case F0=rnorm and Fn=kidney_cor (distribution of kidney cell lines correlation values between cnv and exp).
The p-value below 2.2e-16 so with a significance level of 5% the 0-hypothesis "F0 follows Fn" must be rejected.
Kidney correlation values are not normally distributed.

<https://www.bing.com/videos/search?q=kolmogorov-smirnov+test&&view=detail&mid=DFFE9293A619B4D51667DFFE9293A619B4D51667&&FORM=VRDGAR&ru=%2Fvideos%2Fsearch%3Fq%3Dkolmogorov-smirnov%2Btest%26FORM%3DHDRSC4> <https://de.wikipedia.org/wiki/Kolmogorow-Smirnow-Test>

```{r norm_test_kidney_corr, echo=FALSE}
dim(kidney_cor)
qqplot(rnorm(18560,mean=mean(kidney_cor, na.rm = TRUE)),kidney_cor) 
qqline(rnorm(18560,mean=mean(kidney_cor, na.rm = TRUE)))
ks.test(kidney_cor, "pnorm", mean=mean(kidney_cor, na.rm = TRUE))
```

### dimension reduction

#### clustering

##### of highly effective drugs (2% quantile)

In order to find out if a specific drug mode of action and/or target and therefore pathways are overrepresented in cancer which would give a guiding principle for further drug research, k-means clustering was performed on the highly effective drugs.
The analysis was carried out for cancer in general (high effective drugs on all-cell-line data frame) and for kidney cancer (high effective drugs in kidney cell lines).
First, a data frame containing only the upper 2% quantile of effective drugs was extracted from the prism data frame.

```{r prism.treat_subset_high_eff_drugs, eval=FALSE, include=FALSE}
#Set threshold depending on the distribution of prism 
#prism_threshold<- quantile(prism_NA_0, 0.02, na.rm=TRUE)

# Create an empty vector to store the column names
high_effect_drugs <- c()

# Iterate over each column of the dataset
for (col in colnames(prism_NA_0)) {
  # Check if any value in the column is lower than the threshold
  if (any(prism_NA_0[, col] <= quantile(prism_NA_0, 0.02, na.rm=TRUE))) {
    # If true, append the column name to the vector
    high_effect_drugs<- c(high_effect_drugs, col)
  }
}
#subset of prism.treat for drugs with inhibiting impact on kidney cancer cells
prism.treat.high_effect_drugs<-print(prism.treat[rownames(prism.treat) %in% high_effect_drugs,])

prism_clustering<- prism_NA_0[, rownames(prism.treat.high_effect_drugs)]
```

K-means was performed for k=1:15 and the within-cluster-sum of squared errors (WSS) plotted.
This allowed the identification of 3 clusters.

```{r eval=FALSE, include=FALSE}
#run k-means for k=1 to k=15 clusters, and for each k check the WSS value
#calculate within-square-distance
wss_prism = sapply(1:15,function(k) { 
    kmeans(x=t(prism_clustering), centers =k)$tot.withinss
})
plot(1:15,wss_prism,type='b',pch=19,xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")
```

To further analyse the cluster contents, a data frame for each cluster was created and several characteristics (mode of action, targets,disease area, ...) compared.

```{r eval=FALSE, include=FALSE}
#identification of cluster content
km_prism_cluster = kmeans(t(prism_clustering), 
            centers = 3, 
            nstart = 10)
#print(km_prism_cluster)

#extracts drug ID s for each cluster and stores them in kidney_cluster_list
prism_cluster_list<-list()
for(i in 1:3){
  prism_cluster_list[[i]]<-which(km_prism_cluster$cluster== i)
}
prism.cluster1<-prism.treat[names(prism_cluster_list[[1]]),]
prism.cluster2<-prism.treat[names(prism_cluster_list[[2]]),]
prism.cluster3<-prism.treat[names(prism_cluster_list[[3]]),]
#mode of action
prism.cluster3$moa[which(table(prism.cluster3$moa)!=0)]
dotchart(as.numeric(table(prism.cluster1$moa)))
prism.cluster1.moa<-which(as.numeric(table(prism.cluster1$moa))>10)
prism.cluster.1.moa<-table(prism.cluster1$moa)[prism.cluster1$moa]
prism.cluster.2.moa<-table(prism.cluster2$moa)[which(as.numeric(table(prism.cluster2$moa))>10)]
prism.cluster.3.moa<-table(prism.cluster3$moa)[which(as.numeric(table(prism.cluster3$moa))>10)]
dotchart(as.numeric(table(prism.treat.high_effect_drugs$moa)))
prism.moa<-table(prism.treat.high_effect_drugs$moa)[which(as.numeric(table(prism.treat.high_effect_drugs$moa))>10)]
prism_cluster_all$moa[which(table(prism.treat.high_effect_drugs$moa)>5)]
#disease area
prism.cluster2$disease.area
table(prism.cluster2$disease.area)
table(prism.treat.high_effect_drugs$disease.area)
diseaseareasxxx<-table(prism.treat.high_effect_drugs$disease.area)[which(as.numeric(table(prism.treat.high_effect_drugs$disease.area))>10)]
#target
prism.cluster1$target
dotchart(as.numeric(table(prism.treat.high_effect_drugs$target)[which(as.numeric(table(prism.treat.high_effect_drugs$target))>5)]))
table(prism.treat.high_effect_drugs$target)[which(as.numeric(table(prism.treat.high_effect_drugs$target))>10)]
hist(as.numeric(table(prism.treat.high_effect_drugs$target)[which(as.numeric(table(prism.treat.high_effect_drugs$target)))]))
##which(table(prism.treat.high_effect_drugs$disease.area)!=0)

#dose
hist(prism.treat.high_effect_drugs$dose)



#anteil der mode of actions in den einzelnen cluster
prism_cluster_all<-prism.treat.high_effect_drugs
prism_cluster_all$cluster<-NA
prism_cluster_all$cluster[rownames(prism_cluster_all) %in% rownames(prism.cluster1)]<-1
prism_cluster_all$cluster[rownames(prism_cluster_all) %in% rownames(prism.cluster2)] <-2
prism_cluster_all$cluster[rownames(prism_cluster_all) %in% rownames(prism.cluster3)]<-3
prism_cluster_all_test=

# Number of unique categories
num_categories <- length(unique(prism_cluster_all_test$moa))
# Create a color palette using rainbow colors
library(RColorBrewer)
color_palette <- pal.bands(polychrome)

library(ggplot2)
ggplot(prism_cluster_all_test, aes(x = cluster, fill = moa)) +
  geom_bar() +
  scale_fill_manual(values = color_palette) +
  labs(x = "Cluster", y = "Mode of actions", title = "Mode of actions in highly effectivte drug clusters") +
  theme_minimal()
```

##### of highly effective drugs in kidney cell lines(2% quantile)

```{r cluster_kidney_cl, echo=FALSE}
par(mfrow = c(1,2))
#run k-means for k=1 to k=15 clusters, and for each k check the WSS value
#identify data frame with only high effective drugs in kidney cancer
prism_kidney_clustering<- prism_NA_0[, rownames(prism.treat.kidney.high_effect_drugs)]
#calculate within-square-distance
wss_kidney_prism = sapply(1:15,function(k) { 
    kmeans(x=t(prism_kidney_clustering), centers =k)$tot.withinss
})
plot(1:15,wss_kidney_prism,type='b',pch=19,xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")

#clustern sie nach moa?
#identification of cluster content
#assigns each broad-ID to one of 2 clusters
km_prism_kidney_cluster = kmeans(t(prism_kidney_clustering), 
            centers = 2, 
            nstart = 10)
#print(km_prism_kidney_cluster)

#extracts drug ID s for each cluster and stores them in kidney_cluster_list
prism_kidney_cluster_list<-list()
for(i in 1:2){
  prism_kidney_cluster_list[[i]]<-which(km_prism_kidney_cluster$cluster== i)
}
prism.kidney.cluster1<-prism.treat[names(prism_kidney_cluster_list[[1]]),]
prism.kidney.cluster2<-prism.treat[names(prism_kidney_cluster_list[[2]]),]
#extracts mode of action for drugs in each cluster
#table(prism.kidney.cluster1$moa)
#prism.kidney.cluster2$moa

dotchart(as.numeric(table(prism.kidney.cluster1$moa)))
```

```{r tables}
table(prism.kidney.cluster1$moa)[which(as.numeric(table(prism.kidney.cluster1$moa))>5)]
table(prism.kidney.cluster2$moa)[which(as.numeric(table(prism.kidney.cluster2$moa))>5)]

#kidney targets
table(prism.treat.kidney.high_effect_drugs$target)[which(as.numeric(table(prism.treat.kidney.high_effect_drugs$target))>=5)]
```

#### Principal component analysis

##### for gene expression

Principal component analysis was performed in order to find out if there are similarities within cell lines

```{r PCA_gene_expr, echo=FALSE}
pca_exp_celllines=prcomp(prism.exp, center=FALSE, scale=FALSE)
celllines.exp=prism.cl[rownames(prism.cl) %in% rownames(prism.exp),]
# Make another df
toplot.exp = as.data.frame(pca_exp_celllines$x) 
toplot.exp$DepMap_ID = rownames(toplot.exp)

plot_wCells.exp = merge(toplot.exp, celllines.exp, by = "DepMap_ID")

# Plot
ggplot(plot_wCells.exp, 
       aes(x = PC1, y = PC2, color = lineage)) +
  geom_point() 
```

Soft-tissue-celllines and central-nervous-system-celllines seem to cluster together while prostate and kidney cancer are widely spread over the plot.

##### for copy number variation

```{r PCA_cnv, echo=FALSE}
pca_cnv_celllines=prcomp(prism.cnv, center=FALSE, scale=FALSE)
celllines.cnv=prism.cl[rownames(prism.cl) %in% rownames(prism.cnv),]
# Make another df
toplot.cnv = as.data.frame(pca_cnv_celllines$x) 
toplot.cnv$DepMap_ID = rownames(toplot.cnv)

plot_wCells.cnv = merge(toplot.cnv, celllines.cnv, by = "DepMap_ID")

# Plot
ggplot(plot_wCells.cnv, 
       aes(x = PC1, y = PC2, color = lineage)) +
  geom_point()
```

##### for knockout scores

```{r PCA_achilles, echo=FALSE}
achilles_NA_0 <- prism.achilles
achilles_NA_0[is.na(achilles_NA_0)] <- 0 # ersetze alle NA durch 0
pca_achilles_celllines=prcomp(achilles_NA_0, center=FALSE, scale=FALSE)
celllines.achilles=prism.cl[rownames(prism.cl) %in% rownames(prism.achilles),]
# Make another df
toplot.achilles = as.data.frame(pca_achilles_celllines$x) 
toplot.achilles$DepMap_ID = rownames(toplot.achilles)

plot_wCells.achilles = merge(toplot.achilles, celllines.achilles, by = "DepMap_ID")

# Plot
ggplot(plot_wCells.achilles, 
       aes(x = PC1, y = PC2, color = lineage)) +
  geom_point()
```

### gibts das 2x ??? - Is there a correlation between gene expression and copy number variation?

```{r eval=FALSE, include=FALSE}
cor_g<-matrix()
for (g in colnames(prism.exp_corr_cleaned)) {  
  valse_g = prism.exp_corr_cleaned[,colnames(prism.exp_corr_cleaned) == g]  
  valsc_g = prism.cnv_corr_cleaned[,colnames(prism.cnv_corr_cleaned) == g]  
  cor_g[[g]]=cor(valse_g, valsc_g, method= c("spearman"))  
}  
final_cor = t(data.frame(cor_g))
h= hist(final_cor)
sum(h$counts[(which(h$breaks <= 0))])
sum(h$counts)
sum(h$counts[(which(h$breaks <= 0))])/sum(h$counts)

#correlation values for kidney cell lines
cor_kidney<-matrix()
for (g in colnames(prism.exp_corr_cleaned)) {  
  valse_g_kidney = prism.exp_corr_cleaned[rownames(prism_exp_list[["Kidney Cancer"]]),colnames(prism.exp_corr_cleaned) == g]  
  valsc_g_kidney = prism.cnv_corr_cleaned[rownames(prism_exp_list[["Kidney Cancer"]]),colnames(prism.cnv_corr_cleaned) == g]  
  cor_kidney[[g]]=cor(valse_g_kidney, valsc_g_kidney, method= c("spearman"))  
}  
kidney_cor = t(data.frame(cor_kidney))
hist(kidney_cor)
```

While the general correlation values are widely spread between -0.4 and 0.8 with most values lying on the positive side (84%), the correlation values for kidney cancer seem to normally distributed around 0.025 but with more values having a negative correlation value (34.6%)-\> Statistical test

As the sample size is too large for a Shapiro Wilks test, a qqplot plotting a normal distribution with mean=mean(kidney correlation values) against kidney correlation values was performed.
It shows a clear line.

```{r eval=FALSE, include=FALSE}
qqplot(rnorm(18560,mean=mean(kidney_cor, na.rm = TRUE)),kidney_cor)
ks.test(kidney_cor, "pnorm", mean=mean(kidney_cor, na.rm = TRUE))
```

As p-value \< 2.2e-16, the H~0~-hypothesis must be rejected, so the data is not normally distributed.

### linear regression

## Discussion

kurze Zusammenfassung der Ergebnisse, Diskussion über gewonnen Erkenntnisse, Einschränkungen in der Analyse

## References
