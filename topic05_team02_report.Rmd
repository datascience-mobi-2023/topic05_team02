---
title: "topic05_team02_report"
author: "Jessica Albrecht, Franca Klaeren & Arne Weigel"
date: "2023-07-17"
output:
  html_document:
    toc: yes
    toc_depth: '4'
    df_print: paged
  pdf_document:
    toc: yes
    toc_depth: 4
editor_options:
  markdown:
    wrap: sentence
bibliography: topic05_team02_references.bib
---

# Report

## Introduction

!!!!!!!!!!!!!!!!!!!! Beschreibung der Fragestellung, Vorstellung der publizierten Vorarbeiten,\...

The repurposing of non-oncology drugs, is one way to find potential treatments for cancer in the future.
This offers several advantages over the development of new drugs.
For example, initial study phases can be shortened or skipped altogether because studies have already been completed.
So time and money can be saved through that (@Pushpakom_2018 , @Corsello_2020).

Many drugs interact with multiple targets and biological pathways beyond their originally intended purpose.

## Material and Methods

```{r load_datasets, include=FALSE}
load("C:/Users/Jessica Albrecht/Desktop/Uni/BioInfo Project/cellline_datasets.rda")
load("C:/Users/Jessica Albrecht/Desktop/Uni/BioInfo Project//prism_datasets.rda")
```

The data we used for the project was published by @Corsello_2020 and @Dempster_2019.

#### What data do we have and what does it tell us?

| data set         | explanation                                                                                                                        |
|---------------------|---------------------------------------------------|
| `prism.exp`      | Transcripts per million of the genes (columns) for the cell lines (rows)                                                           |
| `prism.treat`    | information about each drug (rows) and dosis                                                                                       |
| `prism`          | treatment effects (columns) on the cell growth for each cell line (rows)                                                           |
| `prism.achilles` | gene knockout-scores, representing the importance of one gene for cell survival, of every gene (columns) for the cell lines (rows) |
| `prism.cnv`      | copy number values of the genes (columns) for the cell lines (rows)                                                                |
| `prism.cl`       | provides further information about the cell lines (rows)                                                                           |
| `prism.snv`      | further information about the genes (rows)                                                                                         |

### data cleanup

Before we started to work with our data sets, we first had to do some data cleanup.
For that we generated some sub-data sets for the 17 kidney cancer cell lines and for some areas of application we needed to set NA-values to zero.

We set the rownames of prism.cl as cell line names and deleted some rows with information which was not further needed to reduce the amount of data we had.

To get a deeper insight into kidney cancer, we had to take a closer look at the corresponding data.
For this purpose, we extracted sub-datasets from the various prism datasets and saved them as `prism.[...].kidney` .

We have also created lists for `prism`, its top variance(\>= 75% quantile ) `prism_var_list` and `prism.exp`.
In these, the sub-datasets for all cancer types analyzed, are separately accessible such as for Sarcoma: `prism_list[["Sarcoma"]]`

```{r cleanup_cols_prism.cl, include=FALSE}
#reorder columns of prism.cl
colnames(prism.cl)
prism.cl<-prism.cl[,c(1,2,12,6,20,7,19)]

##make cell lines as row names
rownames(prism.cl)=prism.cl$DepMap_ID
```

```{r kidney_cancer_subsets, include=FALSE}
#rownumbers of prism.cl with Kidney Cancer
which(prism.cl$disease== "Kidney Cancer")

prism.cl.kidney= prism.cl[c(which(prism.cl$disease== "Kidney Cancer")),]

#Gives back all cell lines which are kidney-cancer-cell lines
kidney_celllines<-print(prism.cl.kidney[,1])

#Gives back all cell line ACh-numbers which are cancer-cell lines
kidney_celllines_ACH <-rownames(prism.cl.kidney)

#stores only kidney cancer cell lines from other datasets in a new one
prism.exp.kidney <- prism.exp[kidney_celllines_ACH, ]

#for prism dataset
prism.kidney <- prism[rownames(prism) %in% kidney_celllines_ACH,]

#for prism.cnv
#stores only kidney cancer cell lines from other datasets in a new one
prism.cnv.kidney= prism.cnv[kidney_celllines, ]

#for prism.achilles
prism.achilles.kidney<- prism.achilles[rownames(prism.achilles) %in% kidney_celllines_ACH,]
```

```{r NA_0, include=FALSE}
#set NA to 0
prism_NA_0 <- prism
prism_NA_0[is.na(prism_NA_0)] <- 0 

prism.kidney_NA_0<-prism.kidney
prism.kidney_NA_0[is.na(prism.kidney_NA_0)] <- 0

prism.achilles.kidney_NA_0<-prism.achilles.kidney
prism.achilles.kidney_NA_0[is.na(prism.achilles.kidney_NA_0)] <- 0
```

```{r cancer_type_vector, include=FALSE}
unique(prism.cl$disease)
cancertypes<- c(unique(prism.cl$disease))
```

```{r prism_list, include=FALSE}
# Create a list to store data frames for each cancer type
prism_list <- list()

# Loop over the cancertypes vector
for (cancer_type in cancertypes) {
  # Subset the prism.cl data frame for the current cancer type
  cancer_df <- prism.cl[which(prism.cl$disease == cancer_type), ]
  
  # Subset the prism.exp data frame based on the row names from the cancer_df
  prism_subset <- prism_NA_0[rownames(cancer_df), ]
  
  # Store the subsetted prism.exp in the list with the cancer type as the list name
  prism_list[[cancer_type]] <- prism_subset
}
# Access the data frames for specific cancer types from the list
prism_list[["Sarcoma"]]
# Access other cancer types similarly
```

```{r top_var_list, include=FALSE}
prism.var_list<-list()
# Loop over the cancertypes vector
for (cancer_type in names(prism_list)) {
  
  prism.var<- apply(prism_NA_0,MARGIN=2,FUN=var)
  prism.topvar=prism_NA_0[rownames(cancer_df),which(prism.var>=quantile(prism.var,probs=0.75,na.rm=TRUE))]
  
  prism.topvar.NA_0<-prism.topvar
  prism.topvar.NA_0[is.na(prism.topvar.NA_0)]<-0
  # Store the subsetted prism.exp in the list with the cancer type as the list name
  prism.var_list[[cancer_type]] <- prism.topvar.NA_0
}
#retrieve 75% var-quantile for each cancer type:
prism.var_list[[cancer_type]]
```

```{r prism_exp_list, include=FALSE}
# Create a list to store data frames for each cancer type
prism_exp_list <- list()

# Loop over the cancertypes vector
for (cancer_type in cancertypes) {
  # Subset the prism.cl data frame for the current cancer type
  cancer_df <- prism.cl[which(prism.cl$disease == cancer_type), ]
  
  # Subset the prism.exp data frame based on the row names from the cancer_df
  prism_exp_subset <- prism.exp[rownames(cancer_df), ]
  
  # Store the subsetted prism.exp in the list with the cancer type as the list name
  prism_exp_list[[cancer_type]] <- prism_exp_subset
}

# Access the data frames for specific cancer types from the list
prism_exp_list[["lung cancer"]]
# Access other cancer types similarly
```

### Statistical tests

#### Kolmogorov-Smirnov-test

The Kolgomogorov-Smirnov-test can be a one-sample or a two-sample test.
In this report only the one-sample test was used.
The null-hypothesis of this test is: "The random variable X follows the probability distribution F~0~." The empiric distribution F~n~ is then compared to the given distribution F~0~.
The comparitive characteristic is the maximal distance between the two distributions.
The larger the distance the less likely it is for F~0~ to follow F~n~.

#### Anderson-Darling-test

The `ad.test()` allows conclusions about wheater a given data sample follows a particular distribution or not.
In contrast to the Kolmogorov-Smirnov test, more attention is paid to the tails and in R it is possible to consider larger data sets.

## Results

### descriptive statistics

For a quick overview of the content we printed the headlines of the data sets for example for `prism.cl`.

```{r head_prism.cl, echo=FALSE}
head(prism.cl)
```

```{r distribution_histograms, echo=FALSE}
par(mfrow=c(2,2))
hist(unlist(prism), breaks = 60, main = "Histogram of prism", xlab = "treatment effect values")

hist(unlist(prism.exp), breaks = 60, main = "Histogram of prism.exp", xlab = "transcripts per million")

hist(unlist(prism.achilles), breaks = 60,main = "Histogram of prism.achilles", xlab = "gene knockout-scores")

hist(unlist(prism.cnv), main= "Histogram of prism.cnv", xlab="copy number variation", breaks=60)
```

The data distribution of `prism.exp`, `prism.achilles`, `prism.cnv` and `prism` is not normally distributed which was confirmed by `ad.test()` with a p-value\< 2.2e-16.

```{r check_normal_distribution, include=FALSE}
#values as vectors
prism_vector <- unlist(prism)
prism.achilles_vector<-unlist(prism.achilles)
prism.exp_vector<- unlist(prism.exp)
prism.cnv_vector<-unlist(prism.cnv)

# Perform the Anderson-Darling normality test
library(nortest)
hyp_test_prism_distribution<- ad.test(prism_vector)
hyp_test_prism_distribution

hyp_test_prism.achilles_distribution<-ad.test(prism.achilles_vector)
hyp_test_prism.achilles_distribution

hyp_test_prism.exp_vector<-ad.test(prism.exp_vector)
hyp_test_prism.exp_vector

hyp_test_prism.cnv_vector<-ad.test(prism.cnv_vector)
hyp_test_prism.cnv_vector
```

```{r boxplot_prism_cnv_ach, echo=FALSE}
boxplot(
  prism_vector,prism.cnv_vector, prism.achilles_vector,
  outline = FALSE,
  names=c("prism", "prism.cnv", "prism.achilles"))
```

The boxplot of the data shows small inter quartile ranges for `prism.cnv` and `prism.achilles` and a bigger range for the `prism` data set.
This means we have more spreaded values for `prism` than for the other two data sets.

#### Correlation

##### between knock-out scores and expression

In order to search for high effective drugs, targeting essential genes of kidney cancer different steps are needed to be done.

First: calculating the correlation between the achilles knock-out scores and the expression values for each gene, results in correlation values which indicate how essential the genes are.
To calculate the correlation correctly, it is necessary to have the same size and order of data in both data sets.

```{r essential_genes, include=FALSE}
#old~new
#cnv~exp
#exp~ach
#identify missing rows in exp that are present in achilles
diff_rows <- setdiff(rownames(prism.exp.kidney), rownames(prism.achilles.kidney))
diff_rows <- unique(c(diff_rows, setdiff(rownames(prism.achilles.kidney), rownames(prism.exp.kidney))))
#print(diff_rows)

#prism.exp.kidney_corr_cleaned<-prism.exp.kidney
#"ACH-000046" "ACH-000171" "ACH-000313" "ACH-000428" "ACH-000429" "ACH-000457"
#which(rownames(prism.exp.kidney)=="ACH-000457")
#2,4,7,9,10,12
prism.exp.kidney_corr_cleaned<- prism.exp.kidney[-c(2,4,7,9,10,12),]

#identify missing columns that are present in prism.exp.kidney_corr_cleaned but not in achilles
diff_cols <- setdiff(colnames(prism.exp.kidney), colnames(prism.achilles.kidney))
diff_cols <- unique(c(diff_cols, setdiff(colnames(prism.achilles.kidney), colnames(prism.exp.kidney))))
#print(diff_cols)


diff_cols2 <- setdiff(colnames(prism.achilles.kidney), colnames(prism.exp.kidney))
diff_cols2<- unique(c(diff_cols, setdiff(colnames(prism.exp.kidney), colnames(prism.achilles.kidney))))
prism.exp.kidney_corr_cleaned<-prism.exp.kidney_corr_cleaned[-which(colnames(prism.exp.kidney) %in% diff_cols)]
prism.achilles.kidney_corr_cleaned<-prism.achilles.kidney[-which(colnames(prism.achilles.kidney) %in% diff_cols2)]

#reorder rows in an ascending way
#1.step:rownames(prism.exp.kidney_corr_cleaned)
prism.exp.kidney_corr_cleaned<- prism.exp.kidney_corr_cleaned[order(rownames(prism.exp.kidney_corr_cleaned)),]
prism.achilles.kidney_corr_cleaned<- prism.achilles.kidney_corr_cleaned[order(rownames(prism.achilles.kidney_corr_cleaned)),]

#reorder columns by names
prism.exp.kidney_corr_cleaned= prism.exp.kidney_corr_cleaned[,colnames(prism.achilles.kidney_corr_cleaned)]

correlation_ach_exp_kidney<-matrix()
for (g in colnames(prism.achilles.kidney_corr_cleaned)) {  
  valse_g_ach_exp_kidney = prism.achilles.kidney_corr_cleaned[,colnames(prism.achilles.kidney_corr_cleaned) == g]  
  valsc_g_ach_exp_kidney = prism.exp.kidney_corr_cleaned[,colnames(prism.exp.kidney_corr_cleaned) == g]  
  correlation_ach_exp_kidney[[g]]=cor(valse_g_ach_exp_kidney, valsc_g_ach_exp_kidney, method= c("spearman"))  
}  
final_correlation_ach_exp_kidney = t(data.frame(correlation_ach_exp_kidney))

colnames_pos_corr <- colnames(final_correlation_ach_exp_kidney)[which(final_correlation_ach_exp_kidney >= quantile(final_correlation_ach_exp_kidney, 0.98, na.rm = TRUE))]

colnames_neg_corr <- colnames(final_correlation_ach_exp_kidney)[which(final_correlation_ach_exp_kidney <= quantile(final_correlation_ach_exp_kidney, 0.02, na.rm = TRUE))]

high_corr_genenames<-c(colnames_neg_corr, colnames_pos_corr)
```

```{r correlation_histogram, echo=FALSE}
hist(correlation_ach_exp_kidney, breaks = 40, main= "Histogram of the correlation btw. achilles & expression for kidney cell lines  ", xlab="Correlation values" )
qu<-quantile(correlation_ach_exp_kidney, 0.02, na.rm = TRUE)
abline(v=c(-qu,qu), col= "steelblue4", lwd=2)
```

###### **Which drugs do have a high negative effect on the kidney cancer cell lines?**

In order to slow down or even prevent the growth of tumor cells, we are looking for drugs of which a negative value was obtained in the prism screening.
Since the effect should be as strongly negative as possible, it was decided, after considering the distribution of prism values, to classify drugs below a threshold of the 2% quartile of prism values as highly effective drugs.
This resulted in 429 unique drugs and 668 different drug-dose combinations.

```{r neg_effect_drugs, include=FALSE}
#Set threshold depending on the distribution of prism 
prism.kidney_threshold<- quantile(prism.kidney, 0.02, na.rm=TRUE)

                                                
# Create an empty vector to store the column names
high_effect_drugs_kidney <- c()

# Iterate over each column of the dataset
for (col in colnames(prism.kidney_NA_0)) {
  # Check if any value in the column is lower than the threshold
  if (any(prism.kidney_NA_0[, col] <= prism.kidney_threshold)) {
    # If true, append the column name to the vector
    high_effect_drugs_kidney <- c(high_effect_drugs_kidney, col)
  }
}
#subset of prism.treat for drugs with inhibiting impact on kidney cancer cells
#Show/store the filtered rows
prism.treat.kidney.high_effect_drugs<-print(prism.treat[rownames(prism.treat) %in% high_effect_drugs_kidney,])


prism.treat.kidney.high_effect_drugs$target <- as.character(prism.treat.kidney.high_effect_drugs$target)


# Extract all targets as a single character vector
targetgenes_high_effect_drugs_kidney <- 
  unlist(strsplit(prism.treat.kidney.high_effect_drugs$target, ", "))

# Remove any leading/trailing white spaces and NA values
targetgenes_high_effect_drugs_kidneys <- trimws(targetgenes_high_effect_drugs_kidney)
targetgenes_high_effect_drugs_kidney <- targetgenes_high_effect_drugs_kidney[!is.na(targetgenes_high_effect_drugs_kidney)]

# Print the resulting vector of targets
#print(targetgenes_high_effect_drugs_kidney)
```

###### Which genes are target genes?

After identifying both, essential genes and the target genes of the highly effective drugs, we then searched for overlaps between these two groups.

```{r venn_genes, include=FALSE}
# Create a list of the gene names in each vector
set1 <- unique(high_corr_genenames)
set2 <- unique(targetgenes_high_effect_drugs_kidney)

list_venn1<-list(set1, set2)

# Create the Venn diagram
library(VennDiagram)
venn1<-venn.diagram(
  list_venn1 ,
  category.names = c("essential genes(high corr. btw. prism.ach & prism.exp)", "target genes of high effective drugs "),
  fill = c("lightblue", "steelblue4"),
  main ="venn diagram",
  main.fontface= "bold",
  sub = "essential genes vs.target genes of high effective drugs ",
  col= "white",
  cat.pos= 9,
  filename = NULL
)
grid.newpage()

```

```{r venn_diagramm, echo=FALSE}
grid.draw(venn1)
```

This resulted in 21 target genes being identified.

```{r intersect_genes, echo=FALSE}
#find the genes in the intersection
intr_targets <- intersect(set1, set2)
intr_targets
```

###### Details of those target genes

To learn more details about the target genes, both the number and type of occurring mutations or variants of these genes, as well as their correlation values were examined in more detail.

```{r subsets_targets, include=FALSE}
prism.snv_intr_targets<-prism.snv[prism.snv$Hugo_Symbol %in% intr_targets,]

corr_ach_exp_kidney_intr_targets<-final_correlation_ach_exp_kidney[,colnames(final_correlation_ach_exp_kidney) %in% intr_targets]
corr_ach_exp_kidney_intr_targets<-as.data.frame(corr_ach_exp_kidney_intr_targets)

df_corr_ach_exp_kidney_intr_targets <- data.frame(Genes = rownames(corr_ach_exp_kidney_intr_targets), Values = as.numeric(corr_ach_exp_kidney_intr_targets[,1]))
```

```{r plot_details_target_genes, echo=FALSE}

#count_mutations<-as.vector(prism.snv_intr_targets$Hugo_Symbol)
#count_mutations<-table(vector_count_mutations)

#df.count_mutations<-as.data.frame(count_mutations)

library(ggplot2)
library(RColorBrewer)


####mutation plot
color_palette <- brewer.pal(9, "GnBu")

mutation_plot<-ggplot(prism.snv_intr_targets, aes(x = Hugo_Symbol, fill = Variant_Classification)) +
  geom_bar() +
  scale_fill_manual(values = color_palette) +
  labs(x = "gene", y = "Count", title = "Variant classifications of possible target genes") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 55, hjust = 1))

####correlation plot
color_palette_1 <- colorRampPalette(colors = c("steelblue", "steelblue4"))(21)

correlation_plot<-ggplot(df_corr_ach_exp_kidney_intr_targets, aes(x = Genes, y = Values)) +
  geom_bar(stat = "identity", fill=color_palette_1) +
  xlab("target genes") +
  ylab("correlation values") +
  ggtitle("correlation values of target genes")+
  theme(axis.text.x = element_text(angle = 55, hjust = 1))

```

```{r echo=FALSE}
prism.exp.kidney_intr_targets <- prism.exp.kidney[, colnames(prism.exp.kidney) %in% intr_targets]

hist(unlist(prism.exp.kidney_intr_targets), breaks = 20, main = "Histogram of TPM-values of intresting target genes")

library(pheatmap)
library(RColorBrewer)
pheatmap_prism.exp.kidney_intr_targets<-pheatmap(as.matrix(prism.exp.kidney_intr_targets), 
         cluster_cols = TRUE, 
         color= brewer.pal(9, "Blues"),
         border_color = NA,
         scale = "none",
         cluster_rows = FALSE,
         main = "Transcripts per million of interesting target genes",
         angle_col = 45,
         na_col = "orange",
         legend = TRUE,
         legend_breaks = c(3,6,9),
         legend_labels = c("low","middle","high")
         )
```

##### between copy number variation and expression

As genes lead to the production of effector molecules (mRNA, proteins, etc.) it is interesting to see if a gene product associated with a disease (as disease inhibiting or disease promoting factor) can be amplified by a higher or reduced by a lower (0 or 1) number of gene copies in the genome.

In order to perform the correlation analysis the questioned data frames need to have the same dimension and the same order of genes and celllines.

```{r order_cnv&exp_corr, include=FALSE}
### Reordering of cnv and exp for correlation analysis
#identify missing rows in exp that are present in cnv
diff_rows <- setdiff(rownames(prism.cnv), rownames(prism.exp))
diff_rows <- unique(c(diff_rows, setdiff(rownames(prism.exp), rownames(prism.cnv))))

#prism.cnv_corr_cleaned<-prism.cnv[-c("ACH-000309","ACH-000047","ACH-000979","ACH-001024")]
#which(rownames(prism.cnv)=="ACH-001024")
prism.cnv_corr_cleaned<- prism.cnv[-c(85,268,294,307),]

#identify missing columns that are present in cnv but not in exp
diff_cols <- setdiff(colnames(prism.cnv), colnames(prism.exp))
diff_cols <- unique(c(diff_cols, setdiff(colnames(prism.exp), colnames(prism.cnv))))

diff_cols2 <- setdiff(colnames(prism.exp), colnames(prism.cnv))
diff_cols2<- unique(c(diff_cols, setdiff(colnames(prism.cnv), colnames(prism.exp))))
prism.cnv_corr_cleaned<-prism.cnv_corr_cleaned[-which(colnames(prism.cnv) %in% diff_cols)]
prism.exp_corr_cleaned<-prism.exp[-which(colnames(prism.exp) %in% diff_cols2)]

#reorder rows in an ascending way
#1.step:rownames(prism.cnv_corr_cleaned)
prism.cnv_corr_cleaned<- prism.cnv_corr_cleaned[order(rownames(prism.cnv_corr_cleaned)),]
prism.exp_corr_cleaned<- prism.exp_corr_cleaned[order(rownames(prism.exp_corr_cleaned)),]

#reorder columns by names
prism.cnv_corr_cleaned= prism.cnv_corr_cleaned[,colnames(prism.exp_corr_cleaned)]
```

The correlation was computed for each gene once using only the kidney cell line samples and once for the whole data set.
The whole-cell-line correlations show a lower dispersion (values rangig from -0.24 to +0.78) than the correlations computed with only kidney cell lines (range: -0.78 to +0.96) which can be explained by the amount of data.
While 16% of the overall correlation values lie below 0, kidney cell lines had showed lower correlation value (34.7% \<0) Overall, for some genes copy number variation seems to be highly correlated (high copy number variation-\> high gene expression), while for others there's even a negative correlation observable (high cnv-\> low exp).
As the histogram of the correlation values of kidney cell lines seems normally distributed, normality tests were performed.

```{r corr_exp_cnv, include=FALSE}
#correlation values
cor_g<-matrix()
for (g in colnames(prism.exp_corr_cleaned)) {  
  valse_g = prism.exp_corr_cleaned[,colnames(prism.exp_corr_cleaned) == g]  
  valsc_g = prism.cnv_corr_cleaned[,colnames(prism.cnv_corr_cleaned) == g]  
  cor_g[[g]]=cor(valse_g, valsc_g, method= c("spearman"))  
}  
final_cor = t(data.frame(cor_g))
#distribution of correlation values
h_final_cor= hist(final_cor)
#percentage with a correlation value below 0
sum(h_final_cor$counts[(which(h_final_cor$breaks <= 0))])/sum(h_final_cor$counts)

#correlation values for kidney cell lines
cor_kidney<-matrix()
for (g in colnames(prism.exp_corr_cleaned)) {  
  valse_g_kidney = prism.exp_corr_cleaned[rownames(prism_exp_list[["Kidney Cancer"]]),colnames(prism.exp_corr_cleaned) == g]  
  valsc_g_kidney = prism.cnv_corr_cleaned[rownames(prism_exp_list[["Kidney Cancer"]]),colnames(prism.cnv_corr_cleaned) == g]  
  cor_kidney[[g]]=cor(valse_g_kidney, valsc_g_kidney, method= c("spearman"))  
}  
kidney_cor = t(data.frame(cor_kidney))
#distribution of correlation values for kidney cell lines
hist(kidney_cor)
#percentage with a correlation value below 0
h_kidney_cor=hist(kidney_cor)
sum(h_kidney_cor$counts[(which(h_kidney_cor$breaks <= 0))])/sum(h_kidney_cor$counts)
```

```{r hist_corr_exp_cnv, echo=FALSE}
par(mfrow = c(1,2))
#distribution of correlation values
hist(final_cor)
hist(kidney_cor)
```

As the sample size exceeds 5000 it was not possible to perform a Shapiro-Wilks test, so for a first analysis a qqplot was plotted (kidney correlation values against a random normal distibution with `n= sample size` of correlation values and `mean= mean` of correlation values).
The line showing normal distribution did not align with the plotted values.
To confirm this result, a Kolmogorov-Smirnov test (@LotharSachs2006) was performed.
In this case F~0~=`rnorm` and F~n~=`kidney_cor` (distribution of kidney cell lines correlation values between cnv and exp).
The p-value below 2.2e-16 so with a significance level of 5% the F~0~-hypothesis "F~0~ follows F~n~" must be rejected.
Kidney correlation values are not normally distributed.

<https://www.bing.com/videos/search?q=kolmogorov-smirnov+test&&view=detail&mid=DFFE9293A619B4D51667DFFE9293A619B4D51667&&FORM=VRDGAR&ru=%2Fvideos%2Fsearch%3Fq%3Dkolmogorov-smirnov%2Btest%26FORM%3DHDRSC4> <https://de.wikipedia.org/wiki/Kolmogorow-Smirnow-Test>

```{r norm_test_kidney_corr, echo=FALSE}
dim(kidney_cor)
qqplot(rnorm(18560,mean=mean(kidney_cor, na.rm = TRUE)),kidney_cor) 
qqline(rnorm(18560,mean=mean(kidney_cor, na.rm = TRUE)))
ks.test(kidney_cor, "pnorm", mean=mean(kidney_cor, na.rm = TRUE))
```

### dimension reduction

#### clustering

##### of highly effective drugs (2% quantile)

In order to find out if a specific drug mode of action and/or target and therefore pathways are overrepresented in cancer which would give a guiding principle for further drug research, k-means clustering was performed on the highly effective drugs.
The analysis was carried out for cancer in general (high effective drugs on all-cell-line data frame) and for kidney cancer (high effective drugs in kidney cell lines).
First, a data frame containing only the upper 2% quantile of effective drugs was extracted from the `prism` data frame.

```{r prism.treat_subset_high_eff_drugs, eval=FALSE, include=FALSE}
#Set threshold depending on the distribution of prism 
#prism_threshold<- quantile(prism_NA_0, 0.02, na.rm=TRUE)

# Create an empty vector to store the column names
high_effect_drugs <- c()

# Iterate over each column of the dataset
for (col in colnames(prism_NA_0)) {
  # Check if any value in the column is lower than the threshold
  if (any(prism_NA_0[, col] <= quantile(prism_NA_0, 0.02, na.rm=TRUE))) {
    # If true, append the column name to the vector
    high_effect_drugs<- c(high_effect_drugs, col)
  }
}
#subset of prism.treat for drugs with inhibiting impact on kidney cancer cells
prism.treat.high_effect_drugs<-print(prism.treat[rownames(prism.treat) %in% high_effect_drugs,])

prism_clustering<- prism_NA_0[, rownames(prism.treat.high_effect_drugs)]
```

K-means was performed for k=1:15 and the within-cluster-sum of squared errors (WSS) plotted.
This allowed the identification of 3 clusters.

```{r eval=FALSE, include=FALSE}
#run k-means for k=1 to k=15 clusters, and for each k check the WSS value
#calculate within-square-distance
wss_prism = sapply(1:15,function(k) { 
    kmeans(x=t(prism_clustering), centers =k)$tot.withinss
})
plot(1:15,wss_prism,type='b',pch=19,xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")
```

To further analyse the cluster contents, a data frame for each cluster was created and several characteristics (mode of action, targets, disease area, ...) compared.

```{r eval=FALSE, include=FALSE}
#identification of cluster content
km_prism_cluster = kmeans(t(prism_clustering), 
            centers = 3, 
            nstart = 10)
#print(km_prism_cluster)

#extracts drug ID s for each cluster and stores them in kidney_cluster_list
prism_cluster_list<-list()
for(i in 1:3){
  prism_cluster_list[[i]]<-which(km_prism_cluster$cluster== i)
}
prism.cluster1<-prism.treat[names(prism_cluster_list[[1]]),]
prism.cluster2<-prism.treat[names(prism_cluster_list[[2]]),]
prism.cluster3<-prism.treat[names(prism_cluster_list[[3]]),]
##mode of action
#Cluster1
prism.cluster.1.moa<-table(prism.cluster1$moa)[which(as.numeric(table(prism.cluster1$moa))>=5)]
#Cluster2
prism.cluster.2.moa<-table(prism.cluster2$moa)[which(as.numeric(table(prism.cluster2$moa))>=5)]
#Cluster3
prism.cluster.3.moa<-table(prism.cluster3$moa)[which(as.numeric(table(prism.cluster3$moa))>=5)]
#all high effective drugs
plot.new()
dotchart(as.numeric(table(prism.treat.high_effect_drugs$moa)), xlab= "Frequency", ylab="Modes of action", main= "Frequency of each mode of action")
abline(v=10, col="orange")
prism.moa<-table(prism.treat.high_effect_drugs$moa)[which(as.numeric(table(prism.treat.high_effect_drugs$moa))>=10)]

##disease area
table(prism.treat.high_effect_drugs$disease.area)[which(as.numeric(table(prism.treat.high_effect_drugs$disease.area))>5)]

#target
hist(as.numeric(table(prism.treat.high_effect_drugs$target)))
table(prism.treat.high_effect_drugs$target)[which(as.numeric(table(prism.treat.high_effect_drugs$target))>5)]

#dose
hist(prism.treat.high_effect_drugs$dose)

#anteil der mode of actions in den einzelnen cluster
prism_cluster_all<-prism.treat.high_effect_drugs
prism_cluster_all$cluster<-NA
prism_cluster_all$cluster[rownames(prism_cluster_all) %in% rownames(prism.cluster1)]<-1
prism_cluster_all$cluster[rownames(prism_cluster_all) %in% rownames(prism.cluster2)] <-2
prism_cluster_all$cluster[rownames(prism_cluster_all) %in% rownames(prism.cluster3)]<-3

moa_counts<-table(prism_cluster_all$moa)
moa_counts<-names(moa_counts[moa_counts > 5])
prism_cluster_all_test <- prism_cluster_all[prism_cluster_all$moa %in% moa_counts, ]

# Number of unique categories
num_categories <- length(unique(prism_cluster_all_test$moa))
# Create a color palette using rainbow colors
library(RColorBrewer)
color_palette <- pal.bands(polychrome)

library(ggplot2)
ggplot(prism_cluster_all_test, aes(x = cluster, fill = moa)) +
  geom_bar() +
  scale_fill_manual(values = color_palette) +
  labs(x = "Cluster", y = "Mode of actions", title = "Mode of actions in highly effectivte drug clusters") +
  theme_minimal()
```

##### of highly effective drugs in kidney cell lines (2% quantile)

```{r cluster_kidney_cl, echo=FALSE}
par(mfrow = c(1,2))
#run k-means for k=1 to k=15 clusters, and for each k check the WSS value
#identify data frame with only high effective drugs in kidney cancer
prism_kidney_clustering<- prism_NA_0[, rownames(prism.treat.kidney.high_effect_drugs)]
#calculate within-square-distance
wss_kidney_prism = sapply(1:15,function(k) { 
    kmeans(x=t(prism_kidney_clustering), centers =k)$tot.withinss
})
plot(1:15,wss_kidney_prism,type='b',pch=19,xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")

#clustern sie nach moa?
#identification of cluster content
#assigns each broad-ID to one of 2 clusters
km_prism_kidney_cluster = kmeans(t(prism_kidney_clustering), 
            centers = 2, 
            nstart = 10)
#print(km_prism_kidney_cluster)

#extracts drug ID s for each cluster and stores them in kidney_cluster_list
prism_kidney_cluster_list<-list()
for(i in 1:2){
  prism_kidney_cluster_list[[i]]<-which(km_prism_kidney_cluster$cluster== i)
}
prism.kidney.cluster1<-prism.treat[names(prism_kidney_cluster_list[[1]]),]
prism.kidney.cluster2<-prism.treat[names(prism_kidney_cluster_list[[2]]),]
#extracts mode of action for drugs in each cluster
#table(prism.kidney.cluster1$moa)
#prism.kidney.cluster2$moa

dotchart(as.numeric(table(prism.kidney.cluster1$moa)))
```

```{r tables, include=FALSE}
table(prism.kidney.cluster1$moa)[which(as.numeric(table(prism.kidney.cluster1$moa))>5)]
table(prism.kidney.cluster2$moa)[which(as.numeric(table(prism.kidney.cluster2$moa))>5)]

#kidney targets
table(prism.treat.kidney.high_effect_drugs$target)[which(as.numeric(table(prism.treat.kidney.high_effect_drugs$target))>=5)]
```

#### Principal component analysis

##### for gene expression

Principal component analysis was performed in order to find out if there are similarities within cell lines.

```{r PCA_gene_expr, echo=FALSE}
pca_exp_celllines=prcomp(prism.exp, center=FALSE, scale=FALSE)
celllines.exp=prism.cl[rownames(prism.cl) %in% rownames(prism.exp),]
# Make another df
toplot.exp = as.data.frame(pca_exp_celllines$x) 
toplot.exp$DepMap_ID = rownames(toplot.exp)

plot_wCells.exp = merge(toplot.exp, celllines.exp, by = "DepMap_ID")

# Plot
ggplot(plot_wCells.exp, 
       aes(x = PC1, y = PC2, color = lineage)) +
  geom_point() 
```

Soft-tissue-celllines and central-nervous-system-celllines seem to cluster together while prostate and kidney cancer are widely spread over the plot.

##### for copy number variation

```{r PCA_cnv, echo=FALSE}
pca_cnv_celllines=prcomp(prism.cnv, center=FALSE, scale=FALSE)
celllines.cnv=prism.cl[rownames(prism.cl) %in% rownames(prism.cnv),]
# Make another df
toplot.cnv = as.data.frame(pca_cnv_celllines$x) 
toplot.cnv$DepMap_ID = rownames(toplot.cnv)

plot_wCells.cnv = merge(toplot.cnv, celllines.cnv, by = "DepMap_ID")

# Plot
ggplot(plot_wCells.cnv, 
       aes(x = PC1, y = PC2, color = lineage)) +
  geom_point()
```

##### for knockout scores

```{r PCA_achilles, echo=FALSE}
achilles_NA_0 <- prism.achilles
achilles_NA_0[is.na(achilles_NA_0)] <- 0 # ersetze alle NA durch 0
pca_achilles_celllines=prcomp(achilles_NA_0, center=FALSE, scale=FALSE)
celllines.achilles=prism.cl[rownames(prism.cl) %in% rownames(prism.achilles),]
# Make another df
toplot.achilles = as.data.frame(pca_achilles_celllines$x) 
toplot.achilles$DepMap_ID = rownames(toplot.achilles)

plot_wCells.achilles = merge(toplot.achilles, celllines.achilles, by = "DepMap_ID")

# Plot
ggplot(plot_wCells.achilles, 
       aes(x = PC1, y = PC2, color = lineage)) +
  geom_point()
```

### linear regression

```{r r Sortieren von exp und cnv, echo=FALSE}

#identify missing columns that are present in cnv but not in exp
diff_cols= setdiff(colnames(prism.cnv.kidney), colnames(prism.exp.kidney))
diff_cols= unique(c(diff_cols, setdiff(colnames(prism.exp.kidney), colnames(prism.cnv.kidney))))

diff_cols2= setdiff(colnames(prism.exp.kidney), colnames(prism.cnv.kidney))
diff_cols2= unique(c(diff_cols, setdiff(colnames(prism.cnv.kidney), colnames(prism.exp.kidney))))
prism.cnv.kidney_cleaned=prism.cnv.kidney[-which(colnames(prism.cnv.kidney) %in% diff_cols)]
prism.exp.kidney_cleaned=prism.exp.kidney[-which(colnames(prism.exp.kidney) %in% diff_cols2)]

#reorder rows in an ascending way
#1.step:rownames(prism.cnv_corr_cleaned)
prism.cnv.kidney_cleaned= prism.cnv.kidney_cleaned[order(rownames(prism.cnv.kidney_cleaned)),]
prism.exp.kidney_cleaned= prism.exp.kidney_cleaned[order(rownames(prism.exp.kidney_cleaned)),]

#reorder columns by names
prism.cnv.kidney_cleaned= prism.cnv.kidney_cleaned[,colnames(prism.exp.kidney_cleaned)]
```

To further examine the relationship between CNV and expression in kidney cancer a linear regression was performed.
The previously created `prism.exp.kidney_cleaned` and `prism.cnv.kidney_cleaned` were subjugated to a `lm()` function.

```{r linear_regression_cnv_exp, echo=FALSE}
# Perform linear regression for each cell line
predicted_exp= data.frame(matrix(NA, nrow = nrow(prism.exp.kidney_cleaned), ncol = ncol(prism.exp.kidney_cleaned)))
rownames(predicted_exp)= rownames(prism.exp.kidney_cleaned)
colnames(predicted_exp)= colnames(prism.exp.kidney_cleaned)

for (cell_line in rownames(prism.exp.kidney_cleaned)) {
  # Subset the CNV and expression data for the current cell line
  cnv_pre= t(data.frame(prism.cnv.kidney_cleaned[cell_line, , drop = FALSE]))
  exp_pre= t(data.frame(prism.exp.kidney_cleaned[cell_line, , drop = FALSE]))

  # Merge the expression and CNV data by gene
  for_lm= merge(exp_pre, cnv_pre, by = 0)
  colnames(for_lm)= c("gene", "exp", "cnv")
  
  # Fit the linear regression model using the training data
  model= lm(exp ~ cnv, data = for_lm)
  
  # Predict the expression values using the CNV data
  predicted_exp[cell_line, ]= predict(model, newdata = data.frame(cnv = for_lm$cnv))
}

summary(model)$r.squared
```

Linear Regression for expression and CNV data of each kidney cancer cell line.
The `predicted_exp` data frame contains the predicted expression values for each cell line based on a linear regression model using CNV data as the predictor variable.
Each row of `predicted_exp` corresponds to a specific cell line while each column represents predicted expression values for particular genes.
The models respective R-squared value of 0.01 shows - as already suggested by the exp-cnv correlation matrix - that CNV alone acts as a poor predictor for gene expression.
For instance, DNA-methylation, micro-RNAs and Transcription Factors and other regulatory mechanisms play a vital role in regulating gene expression.
Further studies also indicated that especially cancer cells show a poor relationship between CNV and gene expression to possibly deal with increased genome aneuploidy (@Mohanty_2021).

```{r lr_cnv_exp_plot, echo=FALSE}
# Extract coefficients from the model
coefficients= coef(model)

# Extract slope and intercept from coefficients
slope= coefficients[2]
intercept= coefficients[1]

# Create a data frame for plotting the linear function
plot_data= data.frame(cnv = seq(min(prism.cnv.kidney_cleaned), max(prism.cnv.kidney_cleaned), length.out = 100))
plot_data$predicted_exp= intercept + slope * plot_data$cnv

# Get confidence intervals using the predict function
conf_int= predict(model, newdata = data.frame(cnv = plot_data$cnv), interval = "confidence", level = 0.95)

# Merge confidence intervals into the plot data
plot_data= cbind(plot_data, conf_int)

# Calculate R-squared value
r_squared= summary(model)$r.squared

# Create the plot for model
ggplot(plot_data, aes(x = cnv, y = predicted_exp)) +
  geom_line(color = "steelblue", linewidth = 1) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "grey", alpha = 0.3) +
  geom_text(aes(label = paste("Predicted Expression =", round(slope, 2), " * CNV +", round(intercept, 2))), 
            x = min(prism.cnv.kidney_cleaned) + 0.001 * (max(prism.cnv.kidney_cleaned) - min(prism.cnv.kidney_cleaned)), 
            y = min(plot_data$predicted_exp) + 0.65 * (max(plot_data$predicted_exp) - min(plot_data$predicted_exp)), 
            hjust = 0, vjust = 0) +  # Positioning
  annotate("text", x = min(prism.cnv.kidney_cleaned) + 0.001 * (max(prism.cnv.kidney_cleaned) - min(prism.cnv.kidney_cleaned)), 
           y = min(plot_data$predicted_exp) + 0.55 * (max(plot_data$predicted_exp) - min(plot_data$predicted_exp)), 
           label = paste("R^2 =", round(r_squared, 2)), hjust = 0, vjust = 0, size = 4) +  
  labs(x = "CNV", y = "Predicted Expression") +
  ggtitle("Linear Function of lm(exp ~ cnv) with 95% confidence interval") +
  theme_minimal()
```

Linear Function of lm(exp \~ cnv) with 95% confidence interval.
For the 1% of the datapoints were the model can explain a significant degree of variance, an increase of expression is mitigated by higher CNV.

```{r lr_exp_plot, echo=FALSE}
# Calculate R-squared value
r_squared <- summary(model)$r.squared

# Calculate residuals
residuals <- as.vector(t(prism.exp.kidney_cleaned)) - as.vector(t(predicted_exp))

# Calculate the threshold for highlighting
highlight_threshold <- sqrt(1 - r_squared)

Actual = as.vector(t(prism.exp.kidney_cleaned))
Predicted = as.vector(t(predicted_exp))
`lm explains var` = abs(residuals) <= highlight_threshold

# Create a data frame with residuals and highlight column
data_to_plot <- data.frame(Actual,Predicted, residuals,`lm explains var`)

# Create the scatter plot for model with highlighted data points
library(ggplot2)

ggplot(data = data_to_plot, aes(x = Actual, y = Predicted, color = `lm explains var`)) +
  geom_point(size = 1) +
  scale_color_manual(values = c("FALSE" = "grey", "TRUE" = "steelblue"), name = "lm explains var") +
  geom_abline(slope = 1, intercept = 0, linetype = "solid", color = "orange", size = 1) +  # Add red continuous line
  labs(x = "Actual Expression", y = "Predicted Expression") +
  ggtitle("Actual vs. Predicted Expression by lm(exp ~ cnv) ") +
  theme_minimal()
```

Predicted Expression by lm(exp \~ cnv) vs. actual expression .
This plot shows the relationship between the predicted expression by lm(exp \~ cnv) to the actual expression values of `prism.exp.kidney_cleaned`.
Each dot represents a gene with the actual expression as x-coordinate and the predicted one as y-coordinate.
The variation of the blue genes can be explained by the linear regression model.
The variation of grey genes cannot be explained by the model.
Their variation is not within the R-squared value.
A perfect model with a R-squared of 1 would show all genes on the red line y=x.

```{r USING PRISM:ACHILLES AS PREDICTOR, echo=FALSE}

# Identify common columns between the datasets
common_cols= intersect(colnames(prism.achilles.kidney), colnames(prism.exp.kidney))

# Create cleaned datasets with only the common columns
prism.achilles.kidney_cleaned= prism.achilles.kidney[, common_cols]
prism.exp.kidney_cleanedA= prism.exp.kidney[, common_cols]

# Reorder rows in an ascending way based on rownames
prism.achilles.kidney_cleaned= prism.achilles.kidney_cleaned[order(rownames(prism.achilles.kidney_cleaned)),]
prism.exp.kidney_cleanedA= prism.exp.kidney_cleanedA[order(rownames(prism.exp.kidney_cleanedA)),]

# Reorder columns by names
prism.achilles.kidney_cleaned= prism.achilles.kidney_cleaned[, colnames(prism.exp.kidney_cleanedA)]

# Get the common row names between the datasets
common_row_names= intersect(rownames(prism.achilles.kidney_cleaned), rownames(prism.exp.kidney_cleanedA))

# Subset prism.exp.kidney_cleanedA to keep only the rows present in prism.achilles.kidney_cleaned
prism.exp.kidney_cleanedA= prism.exp.kidney_cleanedA[common_row_names, ]

# Reorder rows in both datasets based on common row names
prism.achilles.kidney_cleaned= prism.achilles.kidney_cleaned[common_row_names, ]
prism.exp.kidney_cleanedA= prism.exp.kidney_cleanedA[common_row_names, ]
```

```{r match_?, echo=FALSE}
# Check if row names match between the two datasets
rownames_match= all(rownames(prism.achilles.kidney_cleaned) == rownames(prism.exp.kidney_cleanedA))

  # Perform linear regression for each cell line
  predicted_expA= data.frame(matrix(NA, nrow = nrow(prism.exp.kidney_cleanedA), ncol = ncol(prism.exp.kidney_cleanedA)))
  rownames(predicted_expA)= rownames(prism.exp.kidney_cleanedA)
  colnames(predicted_expA)= colnames(prism.exp.kidney_cleanedA)

  for (cell_line in rownames(prism.exp.kidney_cleanedA)) {
    # Subset the Achilles and expression data for the current cell line
    achilles_preA= t(data.frame(prism.achilles.kidney_cleaned[cell_line, , drop = FALSE]))
    exp_preA= t(data.frame(prism.exp.kidney_cleanedA[cell_line, , drop = FALSE]))

    # Merge the expression and Achilles data by gene
    for_lmA= merge(exp_preA, achilles_preA, by = 0)
    colnames(for_lmA)= c("gene", "exp", "achilles")

    # Fit the linear regression model using the training data
    modelA= lm(exp ~ achilles, data = for_lmA)

    # Predict the expression values using the Achilles data
    predicted_expA[cell_line, ]= predict(modelA, newdata = data.frame(achilles = for_lmA$achilles))
  }

  summary(modelA)$r.squared
```

```{r model_a, echo=FALSE}
# Extract coefficients from the model
coefficientsA= coef(modelA)

# Extract slope and intercept from coefficients
slopeA= coefficientsA[2]
interceptA= coefficientsA[1]

# Create a data frame for plotting the linear function
plot_dataA= data.frame(achilles = seq(min(prism.achilles.kidney_cleaned), max(prism.achilles.kidney_cleaned), length.out = 100))
plot_dataA$predicted_exp= interceptA + slopeA * plot_dataA$achilles

# Get confidence intervals using the predict function
conf_intA= predict(modelA, newdata = data.frame(achilles = plot_dataA$achilles), interval = "confidence", level = 0.95)

# Merge confidence intervals into the plot data
plot_dataA= cbind(plot_dataA, conf_intA)

# Calculate R-squared value
r_squared_A= summary(modelA)$r.squared

# Create the plot for modelA
ggplot(plot_dataA, aes(x = achilles, y = predicted_exp)) +
  geom_line(color = "steelblue", linewidth = 1) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "grey", alpha = 0.3) +
  geom_text(aes(label = paste("Predicted Expression =", round(slopeA, 2), " * Achilles +", round(interceptA, 2))), 
            x = min(prism.achilles.kidney_cleaned) + 0.001 * (max(prism.achilles.kidney_cleaned) - min(prism.achilles.kidney_cleaned)), 
            y = min(plot_dataA$predicted_exp) + 0.45 * (max(plot_dataA$predicted_exp) - min(plot_dataA$predicted_exp)), 
            hjust = 0, vjust = 0) +  # Position on the left side, a bit lower
  annotate("text", x = min(prism.achilles.kidney_cleaned) + 0.001 * (max(prism.achilles.kidney_cleaned) - min(prism.achilles.kidney_cleaned)), 
           y = min(plot_dataA$predicted_exp) + 0.35 * (max(plot_dataA$predicted_exp) - min(plot_dataA$predicted_exp)), 
           label = paste("R^2 =", round(r_squared_A, 2)), hjust = 0, vjust = 0, size = 4) +  # Position on the left side, a bit lower
  labs(x = "Achilles", y = "Predicted Expression") +
  ggtitle("Linear Function of lm(exp ~ achilles)") +
  theme_minimal()
```

Linear Function of lm(exp \~ achilles) with 95% confidence interval.
15% of the variability in the predicted expression can be explained by Gene Knock-out scores.The negative slope where higher achilles scores are associated with a decrease in gene expression might suggest, that the model possibly fits especially well for tumorsuppressor genes.
Nonetheless these interpretations must be done with extreme caution due to the poor fit of the regression model as well as the fact, that tumor suppressor gene expression also underlies regulatory processes within the cell such as micro-RNA's and DNA-methylation @regory_2023).

```{r echo=FALSE}
# Calculate R-squared value
r_squaredA <- summary(modelA)$r.squared

# Calculate residuals
residualsA <- as.vector(t(prism.exp.kidney_cleanedA)) - as.vector(t(predicted_expA))

# Calculate the threshold for highlighting
highlight_thresholdA <- sqrt(1 - r_squaredA)

ActualA = as.vector(t(prism.exp.kidney_cleanedA))
PredictedA = as.vector(t(predicted_expA))
`lm explains var` = abs(residualsA) <= highlight_thresholdA

# Create a data frame with residuals and highlight column
data_to_plotA <- data.frame(ActualA, PredictedA, residualsA, `lm explains var`)

# Create the scatter plot for model with highlighted data points
library(ggplot2)

ggplot(data = data_to_plotA, aes(x = ActualA, y = PredictedA, color = `lm explains var`)) +
  geom_point(size = 1) +
  scale_color_manual(values = c("FALSE" = "grey", "TRUE" = "steelblue"), name = "lm explains var") +
  geom_abline(slope = 1, intercept = 0, linetype = "solid", color = "orange", size = 1) +  # Add red continuous line
  labs(x = "Actual Expression", y = "Predicted Expression") +
  ggtitle("Actual vs. Predicted Expression by lm(exp ~ cnv) ") +
  theme_minimal()
```

Predicted Expression by lm(exp \~ achilles) vs. actual expression .
This plot shows the relationship between the predicted expression by lm(exp \~ achilles) to the actual expression values of `prism.exp.kidney_cleanedA`.
In the `prism.achilles` data set are only 11 of the 17 kidney cancer cell lines as well as different genes.
Therefore both data sets were subjugated to further data clean-up.
Dots represent genes with the actual expression as x-coordinate and the predicted value as y-coordinate.
The variation of the blue genes can be explained by the regression model.
The variation of the majority-forming grey genes cannot be explained by the model.
Their variation is not within the R-squared value.
A perfect model with a R-squared of 1 would show all genes on the red line y=x.

## Discussion

## References
